# Custom Thread Pool

## Описание

Данный проект реализует собственный пул потоков для высоконагруженных серверных приложений с гибкой настройкой параметров, балансировкой задач и расширенным логированием. Пул не использует стандартный `ThreadPoolExecutor`, а предоставляет собственную реализацию с поддержкой нескольких очередей и кастомных политик отказа.

## Основные параметры

- **corePoolSize** — минимальное количество потоков.
- **maxPoolSize** — максимальное количество потоков.
- **keepAliveTime** и **timeUnit** — время простоя потока до завершения.
- **queueSize** — максимальный размер очереди задач.
- **minSpareThreads** — минимальное число свободных потоков.

## Принцип работы

- Для каждой задачи выбирается очередь по принципу Round Robin.
- Каждый поток-воркер обрабатывает задачи из своей очереди.
- Если поток простаивает дольше `keepAliveTime` и общее число потоков превышает `corePoolSize`, поток завершается.
- Если все очереди заполнены, задача отклоняется через `RejectedExecutionHandler`.

## Логирование

Пул логирует все ключевые события:
- Создание и завершение потоков
- Принятие и выполнение задач
- Отклонение задач при перегрузке
- Завершение потоков по таймауту

## Демонстрация

В классе `Main` показан пример использования пула:
- Инициализация пула с параметрами
- Отправка задач, превышающих размер очереди
- Демонстрация обработки отказов и корректного завершения

## Анализ производительности

Сравнение с `ThreadPoolExecutor` показало, что при небольшом числе потоков и очередей производительность сопоставима. При увеличении числа очередей и потоков кастомный пул может показывать лучшие результаты за счет меньших блокировок, однако стандартный пул лучше оптимизирован для сложных сценариев.

## Исследование параметров

- **corePoolSize** = 2, **maxPoolSize** = 4, **queueSize** = 5, **keepAliveTime** = 5 сек — оптимальны для средней нагрузки.
- Увеличение `queueSize` снижает количество отказов, но увеличивает задержку задач.
- Увеличение `corePoolSize` и `maxPoolSize` повышает пропускную способность, но увеличивает потребление ресурсов.

## Балансировка и распределение задач

Задачи распределяются по очередям по принципу Round Robin, что обеспечивает равномерную загрузку потоков. Такой подход прост и эффективен для большинства сценариев.

## Запуск

1. Склонируйте репозиторий.
2. Соберите проект с помощью Maven: mvn clean package
3. Запустите класс `Main`:
